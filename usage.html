<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/usage.md at 2019-07-27
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20190727" />
    <meta http-equiv="Content-Language" content="en" />
    <title>Maven Unbound &#x2013; Usage</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script type="text/javascript" src="./js/apache-maven-fluido-1.7.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>Unbound</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2019-07-27<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0.0</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">Overview</li>
    <li><a href="index.html" title="Home"><span class="none"></span>Home</a></li>
    <li><a href="install.html" title="Install CLI"><span class="none"></span>Install CLI</a></li>
    <li class="active"><a href="#"><span class="none"></span>Usage</a></li>
    <li><a href="library.html" title="Use as a Library"><span class="none"></span>Use as a Library</a></li>
    <li><a href="dependencies/index.html" title="CVE Report"><span class="none"></span>CVE Report</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Usage</h1>
<div class="section">
<h2><a name="Json_and_Hocon"></a>Json and Hocon</h2>
<p>Hocon is really a version of Json with less syntax.  Commas can be removed when a value is on a single line.  Colons can be replaced by equals and when a value is an object, the colon or equals can be dropped altogether.  Since these forms are similar we will only give examples in Hocon.  Json examples are the same with the added syntax of colons, quotes for keys and commas.</p>
<p>Another thing to note is that Typesafe Config variable resolving is disabled in favor of Maven&#x2019;s.  This is obviously necessary as resolving variables in Maven&#x2019;s style is preferred even if the two styles are nearly identical.</p>
<div class="section">
<h3><a name="Hocon_Includes_.28the_good_stuff.29"></a>Hocon Includes (the good stuff)</h3>
<p>Hocon has an additional syntax of particular interest to Unbound&#x2019;s use cases. Hocon can include other hocon files.  This means you can abstract arbitrary parts of a multi-module build system into any Hocon file.  Then these build components can be included in sub-modules.  For instance in a file called scalaCompile.conf could be</p>

<div>
<div>
<pre class="source">dependencies = [
  {
    groupId = &quot;org.scala-lang&quot;, artifactId = &quot;scala-library&quot;
    version = &quot;${versionScalaRelease}&quot;, scope = &quot;compile&quot;
  }
]
build {
  plugins = [
    {
      groupId = &quot;org.apache.maven.plugins&quot;, artifactId = &quot;maven-compiler-plugin&quot;
      version = &quot;3.7.0&quot;
      configuration { skip = true, skipMain = true }
    }
    {
      groupId = &quot;net.alchim31.maven&quot;, artifactId = &quot;scala-maven-plugin&quot;
      version = &quot;4.0.2&quot;
      configuration { scalaVersion = &quot;${versionScalaRelease}&quot; }
      executions = [ { goals = [ &quot;compile&quot;, &quot;testCompile&quot; ] } ]
    }
  ]
}
</pre></div></div>

<p>and then in your pom.conf file you have</p>

<div>
<div>
<pre class="source">{
  project {
    artifactId = &quot;my-sub-module&quot;
    properties { versionScalaRelease = &quot;2.12.8&quot; }
    include &quot;scalaCompile.conf&quot;
  }
}
</pre></div></div>

<p>This allows for arbitary abstraction of any part of the maven POM without breaking how reporting aggregration works.  This allows for a nice addition to Maven&#x2019;s existing abstraction functionality without requiring existing code to change.</p></div></div>
<div class="section">
<h2><a name="From_Hocon_to_XML"></a>From Hocon to XML</h2>
<p>Translating Hocon to XML is generally a straight forward process.  Most XML Elements directly translate into ConfigObjects (or JObjects).  Theses two data structures can be thought of as a Map from String to Any.  So the key of the map is the label of the child XML node.  So:</p>

<div>
<div>
<pre class="source">parent { groupId = &quot;bar&quot;, artifactId = &quot;foo&quot; }
</pre></div></div>

<p>becomes</p>

<div>
<div>
<pre class="source">&lt;parent&gt;
  &lt;groupId&gt;bar&lt;/groupId&gt;
  &lt;artifactId&gt;foo&lt;/artifactId&gt;
&lt;/parent&gt;
</pre></div></div>

<p>Here we see both map/object and string conversion.  Hocon also supports Numbers, Doubles, Boolean and Date/Time values.  To convert these to XML, toString and/or render are used to convert them to strings as POM XML converts everything to strings.  Maps and primitive types are always converted in this way.<br />
So <tt>value = true</tt> becomes <tt>&lt;value&gt;true&lt;/value&gt;</tt> and <tt>value2 = -14.5</tt> becomes <tt>&lt;value2&gt;-14.5&lt;/value2&gt;</tt></p></div>
<div class="section">
<h2><a name="Special_Cases"></a>Special Cases</h2>
<p>There are a few exceptions for other types however.</p>
<div class="section">
<h3><a name="Lists"></a>Lists</h3>
<p>Lists are handled differently in pom.xml files.  A parent element is labeled with a pluralized form of a noun and the child elements are all labeled with the same singular form of the noun.  In Hocon this gets compressed to</p>

<div>
<div>
<pre class="source">dependencies = [
  { groupId = &quot;foo&quot;, artifactId = &quot;bar&quot; }
  { groupId = &quot;foo2&quot;, artifactId = &quot;bar2&quot; }
]
</pre></div></div>

<p>So this Hocon becomes the following XML</p>

<div>
<div>
<pre class="source">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;foo&lt;/groupId&gt;
    &lt;artifactId&gt;bar&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;foo2&lt;/groupId&gt;
    &lt;artifactId&gt;bar2&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre></div></div>

<p>Notice that the word dependency disappears from the Hocon (and Json) form(s).</p></div>
<div class="section">
<h3><a name="Properties"></a>Properties</h3>
<p>Another difference is how Properties objects are handled in configuration elements.  In Plugins and some other POM model components, there are often a configuration element whose values are bound to fields of the Plugin&#x2019;s Mojo. When the Mojo binds a Properties object, its XML is expressed in this rather verbose way:</p>

<div>
<div>
<pre class="source">&lt;configuration&gt;
  &lt;myProperties&gt;
    &lt;property&gt;
      &lt;name&gt;propertyName1&lt;/name&gt;
      &lt;value&gt;propertyValue1&lt;/value&gt;
    &lt;property&gt;
    &lt;property&gt;
      &lt;name&gt;propertyName2&lt;/name&gt;
      &lt;value&gt;propertyValue2&lt;/value&gt;
    &lt;property&gt;
  &lt;/myProperties&gt;
&lt;/configuration&gt;
</pre></div></div>

<p>In Hocon becomes:</p>

<div>
<div>
<pre class="source">configuration {
  myProperties {
    properties = true
    propertyName1 = &quot;propertyValue1&quot;
    propertyName2 = &quot;propertyValue2&quot;
  }
}
</pre></div></div>

<p>Note the <tt>properties = true</tt> entry that is added.  This way when this Hocon is converted back to XML, it can be converted into the correct XML for the Plugin.  Otherwise, this block of Hocon would be converted to</p>

<div>
<div>
<pre class="source">&lt;configuration&gt;
  &lt;myProperties&gt;
    &lt;propertyName1&gt;propertyValue1&lt;/propertyName1&gt;
    &lt;propertyName2&gt;propertyValue2&lt;/propertyName2&gt;
  &lt;/myProperties&gt;
&lt;/configuration&gt;
</pre></div></div>

<p>by following the general rules of translating XML Elements to Map of String to Any.  See <a class="externalLink" href="https://maven.apache.org/guides/mini/guide-configuring-plugins.html">Configuring Plugins</a> for more information.</p></div>
<div class="section">
<h3><a name="XML_Attributes"></a>XML Attributes</h3>
<p>Even though most Maven POM XML files don&#x2019;t have configuration elements with attributes it does happen.  To handle this case, you must add a special key called <tt>attributeKeys</tt> to your Hocon or Json object to tell Unbound which children to create XML elements for and which ones to create XML attributes for.  So this Hocon</p>

<div>
<div>
<pre class="source">&quot;target&quot; {
  &quot;chmod&quot; { &quot;attributeKeys&quot; = [ &quot;perm&quot; ]
    &quot;perm&quot; = &quot;755&quot;
    &quot;fileset&quot; { &quot;attributeKeys&quot; = [ &quot;dir&quot; ]
      &quot;dir&quot; = &quot;${basedir}/target/deb&quot;
      &quot;include&quot; = { &quot;attributeKeys&quot; = [ &quot;name&quot; ]
        &quot;name&quot; = &quot;usr/bin/mvnu&quot;
      }
    }
  }
}
</pre></div></div>

<p>becomes this XML</p>

<div>
<div>
<pre class="source">&lt;target&gt;
  &lt;chmod perm=&quot;755&quot;&gt;
    &lt;fileset dir=&quot;${basedir}/target/deb&quot;&gt;
      &lt;include name=&quot;usr/bin/mvnu&quot;/&gt;
    &lt;/fileset&gt;
  &lt;/chmod&gt;
&lt;/target&gt;
</pre></div></div>

<p>which is messy but its such a rare case that it hardly matters.</p></div>
<div class="section">
<h3><a name="Shared_Plugin_Configuration"></a>Shared Plugin Configuration</h3>
<p>There are three other special cases that appear because of shared infrastructure supplied by Maven and used by Plugins.  Transformer and Archiver functionality can be used by Plugin authors to provide compression, dependency resolution or other common functionality provided by Maven itself.  These features are configured in commons but special ways.</p>
<div class="section">
<h4><a name="Transformers"></a>Transformers</h4>
<p><a class="externalLink" href="https://maven.apache.org/plugins-archives/maven-shade-plugin-2.0/examples/resource-transformers.html">Transformers</a> are used to merge multiple artifacts into a single large artifact. They are specified in the configuration section of a Plugin.  Here is an example of a piece of XML that configures a Transformer</p>

<div>
<div>
<pre class="source">&lt;transformers&gt;
  &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
    &lt;mainClass&gt;org.apache.maven.unbound.Cli&lt;/mainClass&gt;
  &lt;/transformer&gt;
&lt;/transformers&gt;
</pre></div></div>

<p>would become</p>

<div>
<div>
<pre class="source">transformers = [ { implementation = &quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;, mainClass = &quot;org.apache.maven.unbound.Cli&quot; } ]
</pre></div></div>

<p>Note the only change in usual behavior is that the implementation entry becomes a XML attribute.  Since this is a special case, you don&#x2019;t have to add the attributeKeys list to this Hocon.</p></div>
<div class="section">
<h4><a name="Archivers"></a>Archivers</h4>
<p>An <a class="externalLink" href="http://maven.apache.org/shared/maven-archiver/index.html">Archiver</a> is a piece of shared code that compresses a group of files into one artifact such as a Jar file.  They are configured in the configuration section of a Plugin and always have the label archiver.  For example the following block of XML specifies that a manifest file should be created with a certain main class and the classpath should be added to the manifest.  Also entries in another file should be added to the manifest of this artifact.  Here is the XML:</p>

<div>
<div>
<pre class="source">&lt;archive&gt;
  &lt;manifest&gt;
    &lt;addClasspath&gt;true&lt;/addClasspath&gt;
    &lt;mainClass&gt;com.footballradar.jpademo.App&lt;/mainClass&gt;
  &lt;/manifest&gt;
  &lt;manifestFile&gt;src/main/resources/Manifest.txt&lt;/manifestFile&gt;
&lt;/archive&gt;
</pre></div></div>

<p>which becomes</p>

<div>
<div>
<pre class="source">archive {
  manifestFile = &quot;src/main/resources/Manifest.txt&quot;
  manifest { addClasspath = true, mainClass = &quot;com.footballradar.jpademo.App&quot; }
}
</pre></div></div>
</div>
<div class="section">
<h4><a name="Filesets"></a>Filesets</h4>
<p>A <a class="externalLink" href="https://maven.apache.org/shared/file-management/fileset.html">Fileset</a> is a piece of shared code that selects a group of files to be mapped to another location.  Its common for plugins to have such functionality so it can be configured in a generic way in a plugin&#x2019;s configuration using a fileset. Here is the XML:</p>

<div>
<div>
<pre class="source">&lt;fileset&gt;
  &lt;directory&gt;src/main/java&lt;/directory&gt;
  &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
  &lt;includes&gt;&lt;include&gt;*.java&lt;/include&gt;&lt;includes&gt;
&lt;/fileset&gt;
</pre></div></div>

<p>becomes in Hocon:</p>

<div>
<div>
<pre class="source">fileset { directory = &quot;src/main/java&quot;, outputDirectory = &quot;target/classes&quot;, includes = [ &quot;*.java&quot; ] }
</pre></div></div>
</div>
<div class="section">
<h4><a name="Dependencies"></a>Dependencies</h4>
<p>A dependency is a commonly used part of a POM file.  Often Plugins will also have lists of dependencies in their configuration sections.  When a Hocon object is composed entirely of keys that match the keys of a dependency object, the Hocon will be translated into XML in the following way:</p>

<div>
<div>
<pre class="source">defineBridge = [ { groupId = &quot;org.scala-sbt&quot;, artifactId = &quot;compiler-bridge_${version.scala.epoch}&quot;, version = &quot;${version.scala.zinc}&quot; } ]
defineCompiler = [ { groupId = &quot;org.scala-lang&quot;, artifactId = &quot;scala-compiler&quot;, version = &quot;${version.scala.release}&quot; } ]
</pre></div></div>

<p>becomes</p>

<div>
<div>
<pre class="source">&lt;defineBridge&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.scala-sbt&lt;/groupId&gt;
    &lt;artifactId&gt;compiler-bridge_${version.scala.epoch}&lt;/artifactId&gt;
    &lt;version&gt;${version.scala.zinc}&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/defineBridge&gt;
&lt;defineCompiler&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.scala-lang&lt;/groupId&gt;
    &lt;artifactId&gt;scala-compiler&lt;/artifactId&gt;
    &lt;version&gt;${version.scala.release}&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/defineCompiler&gt;
</pre></div></div>

<p>Notice that the normal pattern is applied except that the XML produced doesn&#x2019;t try to compute the child label from defineBridge or defineCompiler but instead uses &quot;dependency&quot; instead.  It does this when all the child labels (&quot;groupId&quot;, &quot;artifactId&quot; and &quot;version&quot;) are valid parts of a Maven Dependency object.</p></div></div></div>
<div class="section">
<h2><a name="Complete_Samples"></a>Complete Samples</h2>
<p>Here is an example of a simple Hocon POM file that builds a libarary jar.</p>

<div>
<div>
<pre class="source">{
  project {
    groupId = &quot;my-group&quot;, artifactId = &quot;unbound-lib&quot;
    properties { versionScalaRelease = &quot;2.12.8&quot; }
    # from example in the beginning of this page
    include &quot;scalaCompile.conf&quot;
    dependencies += { artifactId = &quot;scala-xml_${version.scala.epoch}&quot;, groupId = &quot;org.scala-lang.modules&quot;, version = &quot;1.2.0&quot; },
    dependencies += { artifactId = &quot;ficus_${version.scala.epoch}&quot;, groupId = &quot;com.iheart&quot;, version = &quot;1.4.6&quot; }
    dependencies += { artifactId = &quot;json4s-native_${version.scala.epoch}&quot;, groupId = &quot;org.json4s&quot;, version = &quot;3.6.6&quot; }
    dependencies += { artifactId = &quot;scalatest_${version.scala.epoch}&quot;, groupId = &quot;org.scalatest&quot;, scope = &quot;test&quot;, version = &quot;${version.scalatest}&quot; }
  }
}
</pre></div></div>

<p>Here is an example of a simple Hocon POM file.  That builds scala code and uses shade to create an executable jar.</p>

<div>
<div>
<pre class="source">{
  project {
    artifactId = &quot;unbound&quot;
    properties { versionScalaRelease = &quot;2.12.8&quot; }
    # from example in the beginning of this page
    include &quot;scalaCompile.conf&quot;
    dependencies += { artifactId = &quot;scala-xml_${version.scala.epoch}&quot;, groupId = &quot;org.scala-lang.modules&quot;, version = &quot;1.2.0&quot; }
    dependencies += { artifactId = &quot;ficus_${version.scala.epoch}&quot;, groupId = &quot;com.iheart&quot;, version = &quot;1.4.6&quot; }
    dependencies += { artifactId = &quot;json4s-native_${version.scala.epoch}&quot;, groupId = &quot;org.json4s&quot;, version = &quot;3.6.6&quot; }
    dependencies += { artifactId = &quot;maven-model&quot;, groupId = &quot;org.apache.maven&quot;, version = &quot;3.6.1&quot; }
    dependencies += { artifactId = &quot;maven-shared-utils&quot;, groupId = &quot;org.apache.maven.shared&quot;, version = &quot;3.2.1&quot; }
    dependencies += { artifactId = &quot;scalatest_${version.scala.epoch}&quot;, groupId = &quot;org.scalatest&quot;, scope = &quot;test&quot;, version = &quot;${version.scalatest}&quot; }
    build {
      plugins += {
        groupId = &quot;org.apache.maven.plugins&quot;, artifactId = &quot;maven-shade-plugin&quot;, version = &quot;3.2.1&quot;
        executions = [ {
          configuration {
            minimizeJar = true, shadedArtifactAttached = true, shadedClassifierName = &quot;exec&quot;
            transformers = [ {
                implementation = &quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;, mainClass = &quot;org.apache.maven.unbound.Cli&quot;
            } ]
          }
          goals = [ &quot;shade&quot; ], phase = &quot;package&quot;
        } ]
      }
    }
  }
}
</pre></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2019.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
